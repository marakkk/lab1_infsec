# Лабораторная работа 1 по дисциплине «Информационная безопасность»

## Описание проекта
В рамках данной лабораторной работы был реализован REST API на **Java (Spring Boot)** с использованием **PostgreSQL** в качестве базы данных. Также для проверки внедренных мер защиты была добавлена интеграция с CI/CD (GitHub Actions) для запуска автоматических security-сканеров (SAST/SCA).

---

## API эндпоинты

По условию требовалось реализовать несколько эндпоинтов, а именно POST /auth/login и GET /api/data, а также ещё один придумать. В качестве произвольного эндоипнта был взять POST api/data, который позволяет создавать новую запись от конкретного пользователя.

### Аутентификация
- **POST /auth/login** — метод для аутентификации пользователя.
  Принимает логин и пароль в формате JSON:
  ```json
  {
    "username": "test_user",
    "password": "123"
  }
  ```
  Пример вызова ендпоинта с помощью **curl**:
  ```bash
  curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test_user1","password":"123"}'
  ```
  Ожидаемый ответ:
  ```json
  {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6..."
  }
  ```

### Работа с данными
> Все эндпоинты ниже требуют заголовок `Authorization: Bearer <jwt>`, поскольку доступ должен быть только у аутенфицированных пользователей.

- **GET /api/data** — метод для получения списка зарегистрированных пользователей (ограниченного доступом по JWT).

  Пример вызова ендпоинта с помощью **curl**:
  ```bash
  curl -X GET http://localhost:8080/api/data \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6..."
  ```
  Ожидаемый ответ:
  ```json
  [{"id":1,"username":"test_user1"}]
  ```

- **POST /api/data**  — метод для создания новой записи (например, поста).  

  Пример вызова ендпоинта с помощью **curl**:
  ```bash
  curl -X POST http://localhost:8080/api/data \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6..."
  -d '{"title":"My first item","content":"This is a test content"}'
  ```
  Ожидаемый ответ:
  ```json
  {"id":6,"title":"My first item","owner":"test_user1","content":"This is a test content"}  
  ```

---

## Реализованные меры защиты


### 1. Защита от SQL-инъекций (SQLi)
- В проекте используется **Spring Data JPA (Hibernate)** для работы с базой данных PostgreSQL.
- Все запросы строятся через ORM и параметризованные методы (`findByUsername`, `save` и т.д.), что полностью исключает возможность подстановки SQL через строковую конкатенацию.

### 2. Защита от XSS (Cross-Site Scripting)
- API возвращает только **JSON-ответы**.
- Дополнительно можно включена обработка входных данных: каждое поле имеет аннотации, которые определяют диапазон, в который должно входить поле. Кроме того, String (имя и тип) имеют @Pattern , которая реализует ограничение регулярного выражения, которое принимает только буквы и пробелы. Это предотвращает попытки злоумышленников использовать специальные символы и символы, которые могут иметь значение в контекстах кода, таких как база данных или браузер.

### 3. Защита от Broken Authentication
- Реализована аутентификация на основе **JWT (JSON Web Token)**:
  - При успешном входе в систему (`POST /auth/login`) сервер возвращает токен, подписанный секретным ключом (алгоритм **HS256**).
  - Токен содержит идентификатор пользователя (`sub`) и время жизни (`exp`).
- Все защищённые эндпоинты (GET/POST `/api/data` ) проверяются через **JwtFilter**, который:
  1. Извлекает токен из заголовка `Authorization: Bearer ...`
  2. Проверяет его валидность
  3. Извлекает имя пользователя и подставляет его в `HttpServletRequest`
- Доступ к данным возможен только при наличии валидного токена.
- Пароли пользователей **никогда не хранятся в открытом виде**:
  - Перед сохранением пароль хэшируется с помощью **BCrypt**.
  - При логине введённый пароль сравнивается с хэшем через `BCryptPasswordEncoder.matches()`.
---

## Скриншоты CI/CD

### Отчёт SAST (SpotBugs)
![img.png](img.png)

### Отчёт SCA (Dependency-Check)
![img_1.png](img_1.png)
